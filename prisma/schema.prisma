generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// MODELS
// IMPORTANTE DEFINIR RELACIONES EN AMBOS MODELOS (AMBOS SENTIDOS, BIDIRECCIONAL)
//TABLAS DE STATUS
model openPayBasicStatus{
  idOpenPayBasicStatus Int @id @default(autoincrement())
  status String
  customUsers customUser[]
}
model openPaySubscriptionStatus{
  idOpenPaySubscriptionStatus Int @id @default(autoincrement())
  status String
}
model statusAfterRetry{
  idStatusAfterRetry Int @id @default(autoincrement())
  status String
}

//TABLAS DE DIRECCIONES
model countryCode {
  idCountryCode Int @id @default(autoincrement())
  countryCode String
  addDate DateTime @default(now())
  updateDate DateTime @updatedAt
  // RELACIONES
  addresses address[]
}

model addressComponent{
  idAddressComponent Int @id @default(autoincrement())
  component String //condominio, suite o delegacion
  // RELACIONES
  adress address []
}

model address{
  idAddress Int @id @default(autoincrement())
  street String
  outerNumber String
  interiorNumber String?
  addressComponentsId Int
  cologne String
  postalCode String
  state String
  city String
  countryCodeId Int
  // RELACIONES
  countryCode countryCode @relation(fields: [countryCodeId], references: [idCountryCode])
  customUsers customUser[]
  addressComponents addressComponent[]
}

//TABLAS DE USUARIOS
model store{
  idStore Int @id @default(autoincrement())
  reference String
  barcode_url String?
  paybin_reference String?
  barcode_paybin_url String?
  customUser customUser[]
}

model userRole{
  idUserRole Int @id @default(autoincrement())
  role String
  baseUser baseUser[]
}

model baseUser {
  idBaseUser Int @id @default(autoincrement())
  name String
  lastName String?
  email String @unique
  password String
  is_staff Boolean @default(false)
  roleId Int
  customUserId Int
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  // RELACIONES
  role userRole @relation(fields: [roleId], references: [idUserRole])
  customUser customUser @relation(fields: [customUserId], references: [idCustomUser])
}


model customUser {
  idCustomUser Int @id @default(autoincrement())
  phoneNumber String?
  openPayBasicStatusId Int
  balance Float
  clabe String?
  birthDate DateTime
  addressId Int
  storeId Int
  groupId Int
  isRefresh Boolean @default(false)
  openpayId String?
  // RELACIONES
  openPayBasicStatus openPayBasicStatus @relation(fields: [openPayBasicStatusId], references: [idOpenPayBasicStatus])
  baseUser baseUser[]
  address address @relation(fields: [addressId], references: [idAddress])
  store store @relation(fields: [storeId], references: [idStore])
}

//TABLAS DE CARDS
model bank{
  idBank Int @id @default(autoincrement())
  name String
  code String
}

model cardBrand{
  idCardBrand Int @id @default(autoincrement())
  brand String
}

model cardType{
  idCardType Int @id @default(autoincrement())
  type String
}

model Card{
  idCard Int @id @default(autoincrement())
  cardOpenPayId String
}


model Form {
  id       Int @id @default(autoincrement())
  name String
  email String
  message String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Products {
  id              Int     @id @default(autoincrement())
  name            String
  price           Float
  quantity        String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Plans{
  id Int @id @default(autoincrement())
  name String
  amount Float //monto que se cobrará cada vez
  currency String //moneda
  repeat_every Int //numero de veces (2 indica dos {repeat_unit})
  repeat_unit String //week, month, year
  retry_times Int //numero de intentos de cobro de la suscripción
  status String //active o deleted
  status_after_retry String //unpaid o cancelled (status una vez se agoten intentos de retry)
  trial_days Int
  openpayId          String?  @unique // id del plan en openpay
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
